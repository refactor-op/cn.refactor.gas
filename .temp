// 完整的 Attribute Benchmark
// 使用方式：
// 1. dotnet new console -n AttributeBench
// 2. cd AttributeBench
// 3. dotnet add package BenchmarkDotNet
// 4. 替换 Program.cs 为此文件
// 5. dotnet run -c Release

using System;
using System.Buffers;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

#region Core Types (共享)

/// <summary>操作码</summary>
public enum OpCode : byte
{
    LoadBase = 0,
    LoadSlot = 1,
    LoadConstant = 2,
    Add = 3,
    Multiply = 4,
}

/// <summary>公式接口</summary>
public interface IFormula<T> where T : struct
{
    int SlotCount { get; }
    T Calculate(T baseValue, ReadOnlySpan<T> slots);
}

/// <summary>Float 公式（不可变）</summary>
public readonly struct FormulaFloat : IFormula<float>
{
    private readonly byte[] _bytecode;
    private readonly int _slotCount;
    private readonly int _maxStackDepth;

    internal FormulaFloat(byte[] bytecode, int slotCount, int maxStackDepth)
    {
        _bytecode = bytecode;
        _slotCount = slotCount;
        _maxStackDepth = maxStackDepth;
    }

    public int SlotCount => _slotCount;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float Calculate(float baseValue, ReadOnlySpan<float> slots)
    {
        Span<float> stack = stackalloc float[_maxStackDepth];
        var stackPtr = 0;

        ReadOnlySpan<byte> code = _bytecode;
        var pc = 0;

        while (pc < code.Length)
        {
            var opCode = (OpCode)code[pc++];

            switch (opCode)
            {
                case OpCode.LoadBase:
                    stack[stackPtr++] = baseValue;
                    break;

                case OpCode.LoadSlot:
                    {
                        var slotIndex = ReadInt32(code, ref pc);
                        var value = slotIndex < slots.Length ? slots[slotIndex] : 0f;
                        stack[stackPtr++] = value;
                    }
                    break;

                case OpCode.LoadConstant:
                    {
                        var value = ReadSingle(code, ref pc);
                        stack[stackPtr++] = value;
                    }
                    break;

                case OpCode.Add:
                    {
                        var b = stack[--stackPtr];
                        var a = stack[--stackPtr];
                        stack[stackPtr++] = a + b;
                    }
                    break;

                case OpCode.Multiply:
                    {
                        var b = stack[--stackPtr];
                        var a = stack[--stackPtr];
                        stack[stackPtr++] = a * b;
                    }
                    break;
            }
        }

        return stack[0];
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ReadInt32(ReadOnlySpan<byte> code, ref int pc)
    {
        var value = code[pc] | (code[pc + 1] << 8) | (code[pc + 2] << 16) | (code[pc + 3] << 24);
        pc += 4;
        return value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float ReadSingle(ReadOnlySpan<byte> code, ref int pc)
    {
        var bits = ReadInt32(code, ref pc);
        return BitConverter.Int32BitsToSingle(bits);
    }
}

/// <summary>Float 公式构建器</summary>
public ref struct FormulaBuilderFloat
{
    private const int InitialBufferSize = 64;
    private const int MaxBufferSize = 65536;

    private static readonly ArrayPool<byte> _pool = ArrayPool<byte>.Shared;
    private byte[] _buffer;
    private int _position;
    private int _maxSlot;

    private FormulaBuilderFloat(int initialCapacity)
    {
        _buffer = _pool.Rent(initialCapacity);
        _position = 0;
        _maxSlot = -1;
    }

    public static FormulaBuilderFloat Create() => new(InitialBufferSize);

    public FormulaBuilderFloat LoadBase()
    {
        var span = GetSpan(1);
        span[0] = (byte)OpCode.LoadBase;
        Advance(1);
        return this;
    }

    public FormulaBuilderFloat LoadSlot(int slotIndex)
    {
        if (slotIndex > _maxSlot)
            _maxSlot = slotIndex;

        var span = GetSpan(5);
        span[0] = (byte)OpCode.LoadSlot;
        WriteInt32(span[1..], slotIndex);
        Advance(5);
        return this;
    }

    public FormulaBuilderFloat Add()
    {
        var span = GetSpan(1);
        span[0] = (byte)OpCode.Add;
        Advance(1);
        return this;
    }

    public FormulaBuilderFloat Multiply()
    {
        var span = GetSpan(1);
        span[0] = (byte)OpCode.Multiply;
        Advance(1);
        return this;
    }

    public FormulaFloat Build()
    {
        if (_position == 0)
            throw new InvalidOperationException("Formula cannot be empty!");

        var bytecode = new byte[_position];
        Array.Copy(_buffer, 0, bytecode, 0, _position);

        _pool.Return(_buffer);
        _buffer = null;

        Validate(bytecode);
        var maxStackDepth = CalculateMaxStackDepth(bytecode);

        return new FormulaFloat(bytecode, _maxSlot + 1, maxStackDepth);
    }

    #region Private

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Span<byte> GetSpan(int sizeHint)
    {
        EnsureCapacity(_position + sizeHint);
        return _buffer.AsSpan(_position);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Advance(int count) => _position += count;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void WriteInt32(Span<byte> span, int value)
    {
        span[0] = (byte)value;
        span[1] = (byte)(value >> 8);
        span[2] = (byte)(value >> 16);
        span[3] = (byte)(value >> 24);
    }

    private void EnsureCapacity(int capacity)
    {
        if (capacity > _buffer.Length)
            Grow(capacity);
    }

    private void Grow(int minCapacity)
    {
        var newSize = Math.Max(_buffer.Length * 2, minCapacity);
        newSize = Math.Min(newSize, MaxBufferSize);

        if (newSize <= _buffer.Length)
            throw new InvalidOperationException($"Formula exceeds maximum size!");

        var newBuffer = _pool.Rent(newSize);
        Array.Copy(_buffer, 0, newBuffer, 0, _position);
        _pool.Return(_buffer);
        _buffer = newBuffer;
    }

    private static void Validate(byte[] bytecode)
    {
        var pc = 0;
        var stackDepth = 0;

        while (pc < bytecode.Length)
        {
            var opCode = (OpCode)bytecode[pc++];

            switch (opCode)
            {
                case OpCode.LoadBase:
                    stackDepth++;
                    break;

                case OpCode.LoadSlot:
                    if (pc + 4 > bytecode.Length)
                        throw new InvalidOperationException("Incomplete LoadSlot!");
                    pc += 4;
                    stackDepth++;
                    break;

                case OpCode.LoadConstant:
                    if (pc + 4 > bytecode.Length)
                        throw new InvalidOperationException("Incomplete LoadConstant!");
                    pc += 4;
                    stackDepth++;
                    break;

                case OpCode.Add:
                case OpCode.Multiply:
                    if (stackDepth < 2)
                        throw new InvalidOperationException("Stack underflow!");
                    stackDepth -= 1;
                    break;

                default:
                    throw new InvalidOperationException("Unknown OpCode!");
            }
        }

        if (stackDepth != 1)
            throw new InvalidOperationException("Unbalanced formula!");
    }

    private static int CalculateMaxStackDepth(byte[] bytecode)
    {
        var pc = 0;
        var stackDepth = 0;
        var maxStackDepth = 0;

        while (pc < bytecode.Length)
        {
            var opCode = (OpCode)bytecode[pc++];

            switch (opCode)
            {
                case OpCode.LoadBase:
                case OpCode.LoadSlot:
                case OpCode.LoadConstant:
                    if (opCode != OpCode.LoadBase)
                        pc += 4;
                    stackDepth++;
                    maxStackDepth = Math.Max(maxStackDepth, stackDepth);
                    break;

                case OpCode.Add:
                case OpCode.Multiply:
                    stackDepth -= 1;
                    break;
            }
        }

        if (maxStackDepth > 255)
            throw new InvalidOperationException("Stack depth exceeds maximum size!");

        return maxStackDepth;
    }

    #endregion
}

/// <summary>预定义公式</summary>
public static class Formulas
{
    public static class Float
    {
        /// <summary>(base + slot0) * slot1</summary>
        public static FormulaFloat Standard() => FormulaBuilderFloat.Create()
            .LoadBase()
            .LoadSlot(0)
            .Add()
            .LoadSlot(1)
            .Multiply()
            .Build();
    }
}

#endregion

#region 方案 A：当前设计（使用 ArrayPool - 原始版本）

public sealed class AttributeWithArrayPool : IDisposable
{
    private float[] _slots;
    private float _base;
    private FormulaFloat _formula;
    private float _cached;
    private bool _dirty;

    public AttributeWithArrayPool(float @base, FormulaFloat formula)
    {
        _base = @base;
        _formula = formula;
        _slots = ArrayPool<float>.Shared.Rent(formula.SlotCount);
        Array.Clear(_slots, 0, formula.SlotCount);
        _cached = default;
        _dirty = true;
    }

    public float Base => _base;
    public int SlotCount => _formula.SlotCount;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetBase(float value)
    {
        _base = value;
        _dirty = true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetSlot(int slotIndex, float value)
    {
        _slots[slotIndex] = value;
        _dirty = true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float GetValue()
    {
        if (_dirty)
        {
            _cached = _formula.Calculate(_base, _slots.AsSpan(0, _formula.SlotCount));
            _dirty = false;
        }
        return _cached;
    }

    public void Dispose()
    {
        if (_slots != null)
        {
            ArrayPool<float>.Shared.Return(_slots);
            _slots = null!;
        }
    }
}

#endregion

#region 方案 B：直接分配（推荐修改）

public sealed class AttributeWithDirectAllocation : IDisposable
{
    private readonly float[] _slots;
    private float _base;
    private FormulaFloat _formula;
    private float _cached;
    private bool _dirty;

    public AttributeWithDirectAllocation(float @base, FormulaFloat formula)
    {
        _base = @base;
        _formula = formula;
        _slots = new float[formula.SlotCount];  // ✅ 直接分配
        _cached = default;
        _dirty = true;
    }

    public float Base => _base;
    public int SlotCount => _formula.SlotCount;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetBase(float value)
    {
        _base = value;
        _dirty = true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetSlot(int slotIndex, float value)
    {
        _slots[slotIndex] = value;
        _dirty = true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float GetValue()
    {
        if (_dirty)
        {
            _cached = _formula.Calculate(_base, _slots.AsSpan(0, _formula.SlotCount));
            _dirty = false;
        }
        return _cached;
    }

    public void Dispose()
    {
        // 不需要释放，GC 会处理
    }
}

#endregion

#region 方案 C：句柄模式（Formula 共享）

public static class FormulaRegistry
{
    private static readonly Dictionary<int, FormulaFloat> _formulas = new();

    public static void Register(int id, FormulaFloat formula)
    {
        _formulas[id] = formula;
    }

    public static FormulaFloat Get(int id) => _formulas[id];
}

public sealed class AttributeHandle : IDisposable
{
    private int _formulaId;
    private float _base;
    private float _slot0;
    private float _slot1;
    private float _cached;
    private bool _dirty;

    public AttributeHandle(int formulaId, float baseValue)
    {
        _formulaId = formulaId;
        _base = baseValue;
        _dirty = true;
    }

    public float Base => _base;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetBase(float value)
    {
        _base = value;
        _dirty = true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetSlot(int slotIndex, float value)
    {
        if (slotIndex == 0) _slot0 = value;
        else if (slotIndex == 1) _slot1 = value;
        _dirty = true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public float GetValue()
    {
        if (_dirty)
        {
            var formula = FormulaRegistry.Get(_formulaId);
            Span<float> slots = stackalloc float[2];
            slots[0] = _slot0;
            slots[1] = _slot1;
            _cached = formula.Calculate(_base, slots);
            _dirty = false;
        }
        return _cached;
    }

    public void Dispose()
    {
        // 无需释放
    }
}

#endregion

#region Benchmark

[MemoryDiagnoser]
[RankColumn]
public class AttributeBenchmarks
{
    private const int Count = 1000;

    private AttributeWithArrayPool[] _arrayPoolDesign = null!;
    private AttributeWithDirectAllocation[] _directDesign = null!;
    private AttributeHandle[] _handleDesign = null!;

    private FormulaFloat _sharedFormula;

    [GlobalSetup]
    public void Setup()
    {
        _sharedFormula = Formulas.Float.Standard();

        // 方案 A：ArrayPool
        _arrayPoolDesign = new AttributeWithArrayPool[Count];
        for (int i = 0; i < Count; i++)
        {
            _arrayPoolDesign[i] = new AttributeWithArrayPool(100f, _sharedFormula);
            _arrayPoolDesign[i].SetSlot(0, 10f);
            _arrayPoolDesign[i].SetSlot(1, 1.5f);
        }

        // 方案 B：直接分配
        _directDesign = new AttributeWithDirectAllocation[Count];
        for (int i = 0; i < Count; i++)
        {
            _directDesign[i] = new AttributeWithDirectAllocation(100f, _sharedFormula);
            _directDesign[i].SetSlot(0, 10f);
            _directDesign[i].SetSlot(1, 1.5f);
        }

        // 方案 C：句柄
        FormulaRegistry.Register(1, _sharedFormula);
        _handleDesign = new AttributeHandle[Count];
        for (int i = 0; i < Count; i++)
        {
            _handleDesign[i] = new AttributeHandle(1, 100f);
            _handleDesign[i].SetSlot(0, 10f);
            _handleDesign[i].SetSlot(1, 1.5f);
        }
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        foreach (var attr in _arrayPoolDesign)
            attr?.Dispose();
        foreach (var attr in _directDesign)
            attr?.Dispose();
        foreach (var attr in _handleDesign)
            attr?.Dispose();
    }

    // ==================== GetValue (缓存命中) ====================

    [Benchmark(Baseline = true, Description = "GetValue (Cached) - ArrayPool")]
    public float GetValue_Cached_ArrayPool()
    {
        float sum = 0;
        for (int i = 0; i < Count; i++)
            sum += _arrayPoolDesign[i].GetValue();
        return sum;
    }

    [Benchmark(Description = "GetValue (Cached) - Direct")]
    public float GetValue_Cached_Direct()
    {
        float sum = 0;
        for (int i = 0; i < Count; i++)
            sum += _directDesign[i].GetValue();
        return sum;
    }

    [Benchmark(Description = "GetValue (Cached) - Handle")]
    public float GetValue_Cached_Handle()
    {
        float sum = 0;
        for (int i = 0; i < Count; i++)
            sum += _handleDesign[i].GetValue();
        return sum;
    }

    // ==================== GetValue (缓存未命中) ====================

    [Benchmark(Description = "GetValue (Dirty) - ArrayPool")]
    public float GetValue_Dirty_ArrayPool()
    {
        float sum = 0;
        for (int i = 0; i < Count; i++)
        {
            _arrayPoolDesign[i].SetBase(100f + i);  // 触发 dirty
            sum += _arrayPoolDesign[i].GetValue();
        }
        return sum;
    }

    [Benchmark(Description = "GetValue (Dirty) - Direct")]
    public float GetValue_Dirty_Direct()
    {
        float sum = 0;
        for (int i = 0; i < Count; i++)
        {
            _directDesign[i].SetBase(100f + i);
            sum += _directDesign[i].GetValue();
        }
        return sum;
    }

    [Benchmark(Description = "GetValue (Dirty) - Handle")]
    public float GetValue_Dirty_Handle()
    {
        float sum = 0;
        for (int i = 0; i < Count; i++)
        {
            _handleDesign[i].SetBase(100f + i);
            sum += _handleDesign[i].GetValue();
        }
        return sum;
    }

    // ==================== SetSlot ====================

    [Benchmark(Description = "SetSlot - ArrayPool")]
    public void SetSlot_ArrayPool()
    {
        for (int i = 0; i < Count; i++)
            _arrayPoolDesign[i].SetSlot(0, i * 0.1f);
    }

    [Benchmark(Description = "SetSlot - Direct")]
    public void SetSlot_Direct()
    {
        for (int i = 0; i < Count; i++)
            _directDesign[i].SetSlot(0, i * 0.1f);
    }

    [Benchmark(Description = "SetSlot - Handle")]
    public void SetSlot_Handle()
    {
        for (int i = 0; i < Count; i++)
            _handleDesign[i].SetSlot(0, i * 0.1f);
    }

    // ==================== SetBase ====================

    [Benchmark(Description = "SetBase - ArrayPool")]
    public void SetBase_ArrayPool()
    {
        for (int i = 0; i < Count; i++)
            _arrayPoolDesign[i].SetBase(100f + i);
    }

    [Benchmark(Description = "SetBase - Direct")]
    public void SetBase_Direct()
    {
        for (int i = 0; i < Count; i++)
            _directDesign[i].SetBase(100f + i);
    }

    [Benchmark(Description = "SetBase - Handle")]
    public void SetBase_Handle()
    {
        for (int i = 0; i < Count; i++)
            _handleDesign[i].SetBase(100f + i);
    }

    // ==================== 创建开销 ====================

    [Benchmark(Description = "Create - ArrayPool")]
    public AttributeWithArrayPool Create_ArrayPool()
    {
        var attr = new AttributeWithArrayPool(100f, _sharedFormula);
        attr.SetSlot(0, 10f);
        attr.SetSlot(1, 1.5f);
        return attr;
    }

    [Benchmark(Description = "Create - Direct")]
    public AttributeWithDirectAllocation Create_Direct()
    {
        var attr = new AttributeWithDirectAllocation(100f, _sharedFormula);
        attr.SetSlot(0, 10f);
        attr.SetSlot(1, 1.5f);
        return attr;
    }

    [Benchmark(Description = "Create - Handle")]
    public AttributeHandle Create_Handle()
    {
        var attr = new AttributeHandle(1, 100f);
        attr.SetSlot(0, 10f);
        attr.SetSlot(1, 1.5f);
        return attr;
    }
}

#endregion

public class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine("=== Attribute Benchmark ===");
        Console.WriteLine();
        Console.WriteLine("测试项目：");
        Console.WriteLine("1. GetValue (Cached)   - 缓存命中（最常见场景）");
        Console.WriteLine("2. GetValue (Dirty)    - 缓存未命中（每次都重新计算）");
        Console.WriteLine("3. SetSlot             - 设置槽位");
        Console.WriteLine("4. SetBase             - 设置基础值");
        Console.WriteLine("5. Create              - 创建开销");
        Console.WriteLine();
        Console.WriteLine("对比方案：");
        Console.WriteLine("A. ArrayPool   - 原始设计（使用 ArrayPool）");
        Console.WriteLine("B. Direct      - 推荐修改（直接分配）");
        Console.WriteLine("C. Handle      - 句柄模式（Formula 共享）");
        Console.WriteLine();
        Console.WriteLine("开始运行 Benchmark...");
        Console.WriteLine();

        var summary = BenchmarkRunner.Run<AttributeBenchmarks>();
    }
}